Problem Statement:

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants 
(where we allow a node to be a descendant of itself).”

Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

Example 1:
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.

Example 2:
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.



Solution:
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        """
        if not root:
            return
        pli=[]
        qli=[]
        stack=[[root,[root.val]]]
        while stack:
            i,li=stack.pop(0)
            if i==p:
                pli=li
            elif i==q:
                qli=li
            if i.left:
                stack.append([i.left,[root.val,i.left.val]])
            if i.right:
                stack.append([i.right,[root.val,i.right.val]])
        #print(pli)
        #print(qli)
        li=list(set(pli).intersection(set(qli)))
        print(li)
        """
        """
        ####### Recursive
        if p.val>root.val and q.val>root.val:
            return self.lowestCommonAncestor(root.right,p,q)
        elif p.val<root.val and q.val<root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        else:
            return root
        
        """
        
        ##### Iterative
        
        node=root
        while node:
            if p.val>node.val and q.val>node.val:
                node=node.right
            elif p.val<node.val and q.val< node.val:
                node=node.left
            else:
                return node
